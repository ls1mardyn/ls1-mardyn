//
// Created by Kruegener on 1/15/2019.
//

#include "VirialProfile.h"
#include "DensityProfile.h"

void VirialProfile::output(std::string prefix, long unsigned accumulatedDatasets) {

	Log::global_log->info() << "[VirialProfile] output" << std::endl;

	// Setup outfile
	_accumulatedDatasets = accumulatedDatasets;
	_profilePrefix = prefix + "_1D-Y.Vipr";
	std::ofstream outfile(_profilePrefix.c_str());
	outfile.precision(6);

	// Write Header
	outfile << "//Segment volume: " << _samplInfo.segmentVolume << "\n//Accumulated data sets: " << _accumulatedDatasets
			<< "\n//Local profile of the partial pressures. Output file generated by the \"VirialProfile\" method, plugins/profiles. \n";
	outfile << "// \t dX \t dY \t dZ \n";
	outfile << "\t" << 1 / _samplInfo.universalInvProfileUnit[0] << "\t" << 1 / _samplInfo.universalInvProfileUnit[1]
			<< "\t" << 1 / _samplInfo.universalInvProfileUnit[2] << "\n";
	outfile << "0 \t\n";

	// y value, PD, PX, PY, PZ
	outfile << "# y\tvn-vt\tpx\tpy\tpz\n# \n";

	unsigned long unID;
	double layerVolume;
	double layerHeight = _samplInfo.globalLength[1] / _samplInfo.universalProfileUnit[1];
	if (_samplInfo.cylinder) {
		// V = height * PI * R^2
		// Get max radius of the cylinder inside the box domain
		double radius = _samplInfo.globalLength[0]/2;
		layerVolume = layerHeight * M_PI * radius * radius;
	} else {
		// V = height * X * Z
		layerVolume = layerHeight * _samplInfo.globalLength[0] * _samplInfo.globalLength[2];
	}
	// Get current temperature from 0 thermostat -> temperature of all molecules even if not under thermostat control
	double globalTemperature = global_simulation->getDomain()->getCurrentTemperature(0);

	// Pressure increases with "Depth" in Y
	// Calculate Pressures on layer, then write 1D output
	for (unsigned y = 0; y < _samplInfo.universalProfileUnit[1]; y++) {
		double hval = (y + 0.5) / _samplInfo.universalInvProfileUnit[1];
		// Partial pressures
		long double Pd = 0.0;
		long double Px = 0.0;
		long double Py = 0.0;
		long double Pz = 0.0;
		// Molecules in current layer
		long double Ny = 0.0;

		// Build values from new X-Z layer
		// a: x in cart / rho in cyl
		// b: z in cart / phi in cyl
		for (unsigned a = 0; a < _samplInfo.universalProfileUnit[0]; a++) {
			for (unsigned b = 0; b < _samplInfo.universalProfileUnit[2]; b++) {
				if (_samplInfo.cylinder) {
					// CRUCIAL:
					// Do not change unID calculation. Has to be the same as in SpatialProfile.cpp
					// VirialProfile overwrites the default output routine of ProfileBase, so has to calculate unID on its own
					unID = (unsigned long) (y * _samplInfo.universalProfileUnit[0] * _samplInfo.universalProfileUnit[2]
											+ a * _samplInfo.universalProfileUnit[2] + b);
				} else {
					// CRUCIAL:
					// Do not change unID calculation. Has to be the same as in SpatialProfile.cpp
					// VirialProfile overwrites the default output routine of ProfileBase, so has to calculate unID on its own
					unID = (unsigned long) (
							a * _samplInfo.universalProfileUnit[1] * _samplInfo.universalProfileUnit[2] +
							y * _samplInfo.universalProfileUnit[2] + b);
				}
				// Add pressures
				Px += _global3dProfile[unID][0];
				Py += _global3dProfile[unID][1];
				Pz += _global3dProfile[unID][2];
				// Add molecules in layer
				Ny += _densityProfile->getGlobalNumber(unID);
			}
		}
		// Pressure differential
		Pd = Py - .5 * (Px + Pz);

		// Output line
		outfile << hval << "\t"
				<< Pd / (layerVolume * _accumulatedDatasets) << "\t"
				<< (globalTemperature * Ny + Px) / (layerVolume * _accumulatedDatasets) << "\t"
				<< (globalTemperature * Ny + Py) / (layerVolume * _accumulatedDatasets) << "\t"
				<< (globalTemperature * Ny + Pz) / (layerVolume * _accumulatedDatasets) << "\n";

	}

	outfile.close();
}
