#ifndef LOCKS_CUM__
#define LOCKS_CUM__

#include <host_defines.h>

namespace Lock {
	class WaitForFirstWarp {
		volatile uint lockValue;

	public:
		//__device__ WaitForFirstWarp() : lockValue( 0u ) {}
		__device__ void init() {
			lockValue = 0u;
		}

		// first to enter doesn't have to wait, all others do
		// returns whether the thread was the first (true), or not
		__device__ bool lock() {
			uint index = atomicInc( (uint*) &lockValue, ~0u );

			if( index > 0u ) {
				// spin until the first lock notifies all
				while( lockValue > 0u )
					;

				return false;
			}
			return true;
		}

		__device__ void notifyAll() {
			lockValue = 0u;
		}
	};

	// very slow!!
	class OrderedSerializationBlock {
		volatile uint lockValue;

	public:
		//__device__ OrderedSerializationBlock() : lockValue( 0 ) {}
		__device__ void init() {
			lockValue = 0u;
		}

		// first to enter doesn't have to wait, all others do
		// returns whether the thread was the first (true), or not
		__device__ bool enter() {
			uint index = atomicInc( (uint*) &lockValue, ~0u );

			if( index > 0) {
				// spin until the earlier thread is done
				while( lockValue > index )
					;

				return false;
			}
			return true;
		}

		// release all threads
		__device__ void abort() {
			lockValue = 0;
		}

		// now the next thread is allowed to run (if there is one)
		__device__ void leave() {
			atomicDec( (uint*) &lockValue, ~0u );
		}
	};

	class Mutex {
		volatile uint lockValue;

	public:
		//__device__ Mutex() : lockValue( 0u ) {}
		__device__ void init() {
			lockValue = 0u;
		}

		__device__ void lock() {
			while( atomicExch( (uint*) &lockValue, 1u ) != 0u )
				;
		}

		// locks but supports being interrupted when (signal & bitMask) becomes 0
		// returns true if unlocked must be called
		// returns false if unlocked mustn't be called
		// assumption:
		// the signal can only be reset by a warp/thread that is inside the same semaphore,
		// only the caller can set it
		__device__ bool lock(volatile uint *signal, uint bitMask) {
			while( atomicExch( (uint*) &lockValue, 1u ) != 0u ) {
				if( (*signal & bitMask) == 0 ) {
					return false;
				}
			}

			return true;
		}

		__device__ void unlock() {
			lockValue = 0u;
		}
	};
}

#endif
