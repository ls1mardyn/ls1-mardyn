<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ls1-MarDyn: KDNode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ls1-MarDyn
   </div>
   <div id="projectbrief">ls1-MarDyn molecular dynamics code</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classKDNode-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">KDNode Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>represents a node in the decomposition tree when using <a class="el" href="classKDDecomposition.html" title="KD tree based domain decomposition for better load balancing.">KDDecomposition</a>  
 <a href="classKDNode.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="KDNode_8h_source.html">KDNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2b214b0f4e35325b70bf258fccabbff6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classMPIKDNodePacked.html">MPIKDNodePacked</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a2b214b0f4e35325b70bf258fccabbff6">MPIKDNode</a></td></tr>
<tr class="separator:a2b214b0f4e35325b70bf258fccabbff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aae46142c157df5056f52ff344b3d3256"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#aae46142c157df5056f52ff344b3d3256">KDNode</a> (const <a class="el" href="classKDNode.html">KDNode</a> &amp;other)</td></tr>
<tr class="separator:aae46142c157df5056f52ff344b3d3256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98055d1832bdcb3eed68b7028a942e0"><td class="memItemLeft" align="right" valign="top"><a id="ab98055d1832bdcb3eed68b7028a942e0" name="ab98055d1832bdcb3eed68b7028a942e0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>KDNode</b> (int numP, const int low[KDDIM], const int high[KDDIM], int id, int owner, bool coversAll[KDDIM], int level)</td></tr>
<tr class="separator:ab98055d1832bdcb3eed68b7028a942e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a127df226039920fdfe32c4cf652d7e97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a127df226039920fdfe32c4cf652d7e97">equals</a> (<a class="el" href="classKDNode.html">KDNode</a> &amp;other)</td></tr>
<tr class="separator:a127df226039920fdfe32c4cf652d7e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6897b4bd312715a7af295243c9f3ab"><td class="memItemLeft" align="right" valign="top"><a id="aaf6897b4bd312715a7af295243c9f3ab" name="aaf6897b4bd312715a7af295243c9f3ab"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~KDNode</b> ()</td></tr>
<tr class="memdesc:aaf6897b4bd312715a7af295243c9f3ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">The destructor deletes the childs (recursive call of destructors) <br /></td></tr>
<tr class="separator:aaf6897b4bd312715a7af295243c9f3ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab269772c3c3759dadc3306443d621b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKDNode.html">KDNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#ab269772c3c3759dadc3306443d621b7a">findAreaForProcess</a> (int rank)</td></tr>
<tr class="separator:ab269772c3c3759dadc3306443d621b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade982672a7f3f658be5e9ef85900417b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#ade982672a7f3f658be5e9ef85900417b">buildKDTree</a> ()</td></tr>
<tr class="memdesc:ade982672a7f3f658be5e9ef85900417b"><td class="mdescLeft">&#160;</td><td class="mdescRight">create an initial decomposition of the domain represented by this node.  <a href="classKDNode.html#ade982672a7f3f658be5e9ef85900417b">More...</a><br /></td></tr>
<tr class="separator:ade982672a7f3f658be5e9ef85900417b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9cdc802a400014e28ac4d4aad89886"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a7a9cdc802a400014e28ac4d4aad89886">isResolvable</a> ()</td></tr>
<tr class="separator:a7a9cdc802a400014e28ac4d4aad89886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde3e35b9dca37f616785d8607e6ea48"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#afde3e35b9dca37f616785d8607e6ea48">getNumMaxProcs</a> ()</td></tr>
<tr class="separator:afde3e35b9dca37f616785d8607e6ea48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11f273c412cba9a1c8dc7587cdeaa90"><td class="memItemLeft" align="right" valign="top"><a id="af11f273c412cba9a1c8dc7587cdeaa90" name="af11f273c412cba9a1c8dc7587cdeaa90"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>calculateAvgLoadPerProc</b> () const</td></tr>
<tr class="separator:af11f273c412cba9a1c8dc7587cdeaa90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e99a5349d930f8bffcbb47f4ac2e2ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a7e99a5349d930f8bffcbb47f4ac2e2ee">calculateDeviationLowerBound</a> (std::vector&lt; double &gt; *accumulatedProcessorSpeeds=nullptr)</td></tr>
<tr class="separator:a7e99a5349d930f8bffcbb47f4ac2e2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affcf0816b31d9b55ee65a529b671bfaf"><td class="memItemLeft" align="right" valign="top"><a id="affcf0816b31d9b55ee65a529b671bfaf" name="affcf0816b31d9b55ee65a529b671bfaf"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>calculateDeviation</b> (std::vector&lt; double &gt; *processorSpeeds=nullptr, const double &amp;totalMeanProcessorSpeed=1.)</td></tr>
<tr class="separator:affcf0816b31d9b55ee65a529b671bfaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bdc331659c032b643d568d244036223"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a5bdc331659c032b643d568d244036223">getOwningProcs</a> (const int low[KDDIM], const int high[KDDIM], std::vector&lt; int &gt; &amp;procIDs, std::vector&lt; int &gt; &amp;neighbHaloAreas) const</td></tr>
<tr class="separator:a5bdc331659c032b643d568d244036223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82eb8893a77dfbda4859b870858063e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a82eb8893a77dfbda4859b870858063e1">split</a> (int divDimension, int splitIndex, int numProcsLeft)</td></tr>
<tr class="separator:a82eb8893a77dfbda4859b870858063e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf78f68f3838a670249f6cae1c2e7e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#afbf78f68f3838a670249f6cae1c2e7e9">printTree</a> (const std::string &amp;prefix, std::ostream &amp;ostream)</td></tr>
<tr class="memdesc:afbf78f68f3838a670249f6cae1c2e7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">prints this (sub-) tree to stdout  <a href="classKDNode.html#afbf78f68f3838a670249f6cae1c2e7e9">More...</a><br /></td></tr>
<tr class="separator:afbf78f68f3838a670249f6cae1c2e7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63857c6b976e71aba36edf08a205b825"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a63857c6b976e71aba36edf08a205b825">serialize</a> (const std::string &amp;fileName)</td></tr>
<tr class="separator:a63857c6b976e71aba36edf08a205b825"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70be909e3328c9e607a8e8e2c1e20483"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a70be909e3328c9e607a8e8e2c1e20483">deserialize</a> (const std::string &amp;fileName)</td></tr>
<tr class="separator:a70be909e3328c9e607a8e8e2c1e20483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d88f8a64fa092e047ef001bafabf2dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a3d88f8a64fa092e047ef001bafabf2dc">plotNode</a> (const std::string &amp;vtkFile, const std::vector&lt; double &gt; *processorSpeeds=nullptr) const</td></tr>
<tr class="separator:a3d88f8a64fa092e047ef001bafabf2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca5a4d8a52cf80d2b223f12ee8514f67"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classKDNode.html#a2b214b0f4e35325b70bf258fccabbff6">MPIKDNode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#aca5a4d8a52cf80d2b223f12ee8514f67">getMPIKDNode</a> ()</td></tr>
<tr class="separator:aca5a4d8a52cf80d2b223f12ee8514f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab70bf9710c9b0e13c95d03149512274d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#ab70bf9710c9b0e13c95d03149512274d">initMPIDataType</a> ()</td></tr>
<tr class="separator:ab70bf9710c9b0e13c95d03149512274d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1fea720cc35f4fb8672d2b3af6b2101"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#af1fea720cc35f4fb8672d2b3af6b2101">shutdownMPIDataType</a> ()</td></tr>
<tr class="separator:af1fea720cc35f4fb8672d2b3af6b2101"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab182420bd3d64b37db5e3710100fd314"><td class="memItemLeft" align="right" valign="top"><a id="ab182420bd3d64b37db5e3710100fd314" name="ab182420bd3d64b37db5e3710100fd314"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_numProcs</b></td></tr>
<tr class="memdesc:ab182420bd3d64b37db5e3710100fd314"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of procs which share this area <br /></td></tr>
<tr class="separator:ab182420bd3d64b37db5e3710100fd314"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32c853f40cf7203f9859441e14949a12"><td class="memItemLeft" align="right" valign="top"><a id="a32c853f40cf7203f9859441e14949a12" name="a32c853f40cf7203f9859441e14949a12"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_lowCorner</b> [3]</td></tr>
<tr class="memdesc:a32c853f40cf7203f9859441e14949a12"><td class="mdescLeft">&#160;</td><td class="mdescRight">in cells relative to global domain <br /></td></tr>
<tr class="separator:a32c853f40cf7203f9859441e14949a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a974bcaeaf3e34f3ee2e22a243b5fdc4e"><td class="memItemLeft" align="right" valign="top"><a id="a974bcaeaf3e34f3ee2e22a243b5fdc4e" name="a974bcaeaf3e34f3ee2e22a243b5fdc4e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_highCorner</b> [3]</td></tr>
<tr class="memdesc:a974bcaeaf3e34f3ee2e22a243b5fdc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">in cells relative to global domain <br /></td></tr>
<tr class="separator:a974bcaeaf3e34f3ee2e22a243b5fdc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01018375b1e21b5df2b37971a25a1a6"><td class="memItemLeft" align="right" valign="top"><a id="ae01018375b1e21b5df2b37971a25a1a6" name="ae01018375b1e21b5df2b37971a25a1a6"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_coversWholeDomain</b> [KDDIM]</td></tr>
<tr class="memdesc:ae01018375b1e21b5df2b37971a25a1a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">true if the domain in the given dimension is not divided into more than one process <br /></td></tr>
<tr class="separator:ae01018375b1e21b5df2b37971a25a1a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f83180db4c546b3ced8ffe25af5bdf"><td class="memItemLeft" align="right" valign="top"><a id="a63f83180db4c546b3ced8ffe25af5bdf" name="a63f83180db4c546b3ced8ffe25af5bdf"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_nodeID</b></td></tr>
<tr class="memdesc:a63f83180db4c546b3ced8ffe25af5bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">ID of this <a class="el" href="classKDNode.html" title="represents a node in the decomposition tree when using KDDecomposition">KDNode</a>. <br /></td></tr>
<tr class="separator:a63f83180db4c546b3ced8ffe25af5bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a223eb88d71f3c7a474da977996523ee4"><td class="memItemLeft" align="right" valign="top"><a id="a223eb88d71f3c7a474da977996523ee4" name="a223eb88d71f3c7a474da977996523ee4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_owningProc</b></td></tr>
<tr class="memdesc:a223eb88d71f3c7a474da977996523ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">process which owns this <a class="el" href="classKDNode.html" title="represents a node in the decomposition tree when using KDDecomposition">KDNode</a> (only possible for leaf nodes) <br /></td></tr>
<tr class="separator:a223eb88d71f3c7a474da977996523ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35416cdcf74e419e31f8c2b33f61f29f"><td class="memItemLeft" align="right" valign="top"><a id="a35416cdcf74e419e31f8c2b33f61f29f" name="a35416cdcf74e419e31f8c2b33f61f29f"></a>
<a class="el" href="classKDNode.html">KDNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_child1</b></td></tr>
<tr class="memdesc:a35416cdcf74e419e31f8c2b33f61f29f"><td class="mdescLeft">&#160;</td><td class="mdescRight">"left" child of this <a class="el" href="classKDNode.html" title="represents a node in the decomposition tree when using KDDecomposition">KDNode</a> (only used if the child is no leaf) <br /></td></tr>
<tr class="separator:a35416cdcf74e419e31f8c2b33f61f29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f669d96bd3da0c956cb1fe9f4c5c0dc"><td class="memItemLeft" align="right" valign="top"><a id="a6f669d96bd3da0c956cb1fe9f4c5c0dc" name="a6f669d96bd3da0c956cb1fe9f4c5c0dc"></a>
<a class="el" href="classKDNode.html">KDNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_child2</b></td></tr>
<tr class="memdesc:a6f669d96bd3da0c956cb1fe9f4c5c0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">"left" child of this <a class="el" href="classKDNode.html" title="represents a node in the decomposition tree when using KDDecomposition">KDNode</a> (only used if the child is no leaf) <br /></td></tr>
<tr class="separator:a6f669d96bd3da0c956cb1fe9f4c5c0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba2891ca895b41aabb802b7f0411233"><td class="memItemLeft" align="right" valign="top"><a id="aaba2891ca895b41aabb802b7f0411233" name="aaba2891ca895b41aabb802b7f0411233"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_load</b></td></tr>
<tr class="separator:aaba2891ca895b41aabb802b7f0411233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec5ca75085113abc267d81d26a58693"><td class="memItemLeft" align="right" valign="top"><a id="a2ec5ca75085113abc267d81d26a58693" name="a2ec5ca75085113abc267d81d26a58693"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>_optimalLoadPerProcess</b></td></tr>
<tr class="separator:a2ec5ca75085113abc267d81d26a58693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a79791687b5eec746a96dfb0e5bc40"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a42a79791687b5eec746a96dfb0e5bc40">_deviationLowerBound</a></td></tr>
<tr class="separator:a42a79791687b5eec746a96dfb0e5bc40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a039c4c570ee64a8c8ad790610e0e3685"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKDNode.html#a039c4c570ee64a8c8ad790610e0e3685">_deviation</a></td></tr>
<tr class="separator:a039c4c570ee64a8c8ad790610e0e3685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe058b7acce6c9f2a79989c19a2bc059"><td class="memItemLeft" align="right" valign="top"><a id="abe058b7acce6c9f2a79989c19a2bc059" name="abe058b7acce6c9f2a79989c19a2bc059"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>_level</b></td></tr>
<tr class="memdesc:abe058b7acce6c9f2a79989c19a2bc059"><td class="mdescLeft">&#160;</td><td class="mdescRight">level of this node (at root node, level = 0) <br /></td></tr>
<tr class="separator:abe058b7acce6c9f2a79989c19a2bc059"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >represents a node in the decomposition tree when using <a class="el" href="classKDDecomposition.html" title="KD tree based domain decomposition for better load balancing.">KDDecomposition</a> </p>
<dl class="section author"><dt>Author</dt><dd>Martin Buchholz, Wolfgang Eckhardt</dd></dl>
<p>The <a class="el" href="classKDDecomposition.html" title="KD tree based domain decomposition for better load balancing.">KDDecomposition</a> decomposes the domain by recursively splitting the domain into smaller parts. This class is used to represent this decomposition. The root node of the decomposition covers the whole domain, in the first splitting step, this domain is divided into two parts, where each part then has to be divided into several smaller parts. How many parts/regions there depends on the number of processes, each process will get one region. So the KNNode also has to store how many process "share" the current region The leaf nodes of the tree represent the region of the single processes. The regions (the size of the regions) is not stored in some floating-point length unit but in cells. So it is assumed that the domain is discretised with cells and the decomposition is based on distributing those cells (blocks of cells) to the processes </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2b214b0f4e35325b70bf258fccabbff6" name="a2b214b0f4e35325b70bf258fccabbff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b214b0f4e35325b70bf258fccabbff6">&#9670;&nbsp;</a></span>MPIKDNode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classMPIKDNodePacked.html">MPIKDNodePacked</a> <a class="el" href="classKDNode.html#a2b214b0f4e35325b70bf258fccabbff6">KDNode::MPIKDNode</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >MPIKDNodes represent the data of a <a class="el" href="classKDNode.html" title="represents a node in the decomposition tree when using KDDecomposition">KDNode</a> which has to be sent via MPI. MPIKDNodes can be used directly in MPI Send/Receive operations, with mpi_data_type as type. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aae46142c157df5056f52ff344b3d3256" name="aae46142c157df5056f52ff344b3d3256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae46142c157df5056f52ff344b3d3256">&#9670;&nbsp;</a></span>KDNode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">KDNode::KDNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classKDNode.html">KDNode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Copy constructor copies everything except for the children (are set to nullptr!) </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ade982672a7f3f658be5e9ef85900417b" name="ade982672a7f3f658be5e9ef85900417b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade982672a7f3f658be5e9ef85900417b">&#9670;&nbsp;</a></span>buildKDTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KDNode::buildKDTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create an initial decomposition of the domain represented by this node. </p>
<p >Build a KDTree representing a simple initial domain decomposition by bipartitioning the area recursively, always in the dimension with the longest extend. </p>

</div>
</div>
<a id="a7e99a5349d930f8bffcbb47f4ac2e2ee" name="a7e99a5349d930f8bffcbb47f4ac2e2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e99a5349d930f8bffcbb47f4ac2e2ee">&#9670;&nbsp;</a></span>calculateDeviationLowerBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void KDNode::calculateDeviationLowerBound </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>accumulatedProcessorSpeeds</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Calculates a lower bound for the expected deviation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accumulatedProcessorSpeeds</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70be909e3328c9e607a8e8e2c1e20483" name="a70be909e3328c9e607a8e8e2c1e20483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70be909e3328c9e607a8e8e2c1e20483">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KDNode::deserialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read the tree represented by this (root-)node from a (binary) file. </p>

</div>
</div>
<a id="a127df226039920fdfe32c4cf652d7e97" name="a127df226039920fdfe32c4cf652d7e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a127df226039920fdfe32c4cf652d7e97">&#9670;&nbsp;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool KDNode::equals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classKDNode.html">KDNode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >compare the tree represented by this node to another tree. </p>

</div>
</div>
<a id="ab269772c3c3759dadc3306443d621b7a" name="ab269772c3c3759dadc3306443d621b7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab269772c3c3759dadc3306443d621b7a">&#9670;&nbsp;</a></span>findAreaForProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKDNode.html">KDNode</a> * KDNode::findAreaForProcess </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>the area for process rank, i.e. the leaf of this tree with (_owningProc == rank) and (_numProcs == 1).</dd></dl>
<p>If no corresponding node is found, this method returns nullptr! </p>

</div>
</div>
<a id="aca5a4d8a52cf80d2b223f12ee8514f67" name="aca5a4d8a52cf80d2b223f12ee8514f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca5a4d8a52cf80d2b223f12ee8514f67">&#9670;&nbsp;</a></span>getMPIKDNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKDNode.html#a2b214b0f4e35325b70bf258fccabbff6">KDNode::MPIKDNode</a> KDNode::getMPIKDNode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get a MPIDKNode object representing this <a class="el" href="classKDNode.html" title="represents a node in the decomposition tree when using KDDecomposition">KDNode</a>. </p>

</div>
</div>
<a id="afde3e35b9dca37f616785d8607e6ea48" name="afde3e35b9dca37f616785d8607e6ea48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde3e35b9dca37f616785d8607e6ea48">&#9670;&nbsp;</a></span>getNumMaxProcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int KDNode::getNumMaxProcs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>maximum number of processes, which could be assigned to this node. </dd></dl>

</div>
</div>
<a id="a5bdc331659c032b643d568d244036223" name="a5bdc331659c032b643d568d244036223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bdc331659c032b643d568d244036223">&#9670;&nbsp;</a></span>getOwningProcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KDNode::getOwningProcs </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>low</em>[KDDIM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>high</em>[KDDIM], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>procIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>neighbHaloAreas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">low</td><td></td></tr>
    <tr><td class="paramname">high</td><td></td></tr>
    <tr><td class="paramname">procIDs</td><td></td></tr>
    <tr><td class="paramname">neighbHaloAreas</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab70bf9710c9b0e13c95d03149512274d" name="ab70bf9710c9b0e13c95d03149512274d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70bf9710c9b0e13c95d03149512274d">&#9670;&nbsp;</a></span>initMPIDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void KDNode::initMPIDataType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Initialize the mpi datatype. Has to be called once initially. </p>

</div>
</div>
<a id="a7a9cdc802a400014e28ac4d4aad89886" name="a7a9cdc802a400014e28ac4d4aad89886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9cdc802a400014e28ac4d4aad89886">&#9670;&nbsp;</a></span>isResolvable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool KDNode::isResolvable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>true, if the node can be resolved for its number of processes (_numProcs), i.e. each process can have a subdomain of at least 2 cells per dimension. </dd></dl>

</div>
</div>
<a id="a3d88f8a64fa092e047ef001bafabf2dc" name="a3d88f8a64fa092e047ef001bafabf2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d88f8a64fa092e047ef001bafabf2dc">&#9670;&nbsp;</a></span>plotNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KDNode::plotNode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vtkFile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; *&#160;</td>
          <td class="paramname"><em>processorSpeeds</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >plot the leafs of the KDTree with vtk. </p>

</div>
</div>
<a id="afbf78f68f3838a670249f6cae1c2e7e9" name="afbf78f68f3838a670249f6cae1c2e7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf78f68f3838a670249f6cae1c2e7e9">&#9670;&nbsp;</a></span>printTree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KDNode::printTree </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>ostream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prints this (sub-) tree to stdout </p>
<p >For each node, it is printed whether it is a "LEAF" or a "INNER" node, The order of printing is a depth-first walk through the tree, children are always indented two spaces more than there parents </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">prefix</td><td>A string which is printed in front of each line </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63857c6b976e71aba36edf08a205b825" name="a63857c6b976e71aba36edf08a205b825"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63857c6b976e71aba36edf08a205b825">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KDNode::serialize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>fileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Write the tree represented by this (root-)node to a (binary) file, in order to be able to restore the decomposition from disk. </p>

</div>
</div>
<a id="af1fea720cc35f4fb8672d2b3af6b2101" name="af1fea720cc35f4fb8672d2b3af6b2101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1fea720cc35f4fb8672d2b3af6b2101">&#9670;&nbsp;</a></span>shutdownMPIDataType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void KDNode::shutdownMPIDataType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Free the mpi datatype </p>

</div>
</div>
<a id="a82eb8893a77dfbda4859b870858063e1" name="a82eb8893a77dfbda4859b870858063e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82eb8893a77dfbda4859b870858063e1">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void KDNode::split </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>divDimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>splitIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numProcsLeft</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Split this node, i.e. create two children (note, that its children must be nullptr before this call!).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dimension</td><td>the dimension \in [0;KDDIM-1] along which this node is split </td></tr>
    <tr><td class="paramname">splitIndex</td><td>the index of the corner cell for the new left child (note: must be in bigger or equal to _lowCorner[divDimension] + (<a class="el" href="classKDDStaticValues.html#aad422238a9a5e8e9b37aeda11c871336" title="Minimal number of cells in one dimension.">KDDStaticValues::minNumCellsPerDimension</a>-1) and smaller than _highCorner[dimension]. </td></tr>
    <tr><td class="paramname">numProcsLeft</td><td>the number of processors for the left child. The number of processors for the right child is calculated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a039c4c570ee64a8c8ad790610e0e3685" name="a039c4c570ee64a8c8ad790610e0e3685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a039c4c570ee64a8c8ad790610e0e3685">&#9670;&nbsp;</a></span>_deviation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double KDNode::_deviation</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Deviation of the actual assigned load from the optimal load. </p>

</div>
</div>
<a id="a42a79791687b5eec746a96dfb0e5bc40" name="a42a79791687b5eec746a96dfb0e5bc40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a79791687b5eec746a96dfb0e5bc40">&#9670;&nbsp;</a></span>_deviationLowerBound</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double KDNode::_deviationLowerBound</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This is a lower bound for the deviation of the load from the optimal load. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/parallel/<a class="el" href="KDNode_8h_source.html">KDNode.h</a></li>
<li>src/parallel/KDNode.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Feb 17 2025 09:03:57 for ls1-MarDyn by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
